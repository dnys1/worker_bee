// Generated by dart2js (NullSafetyMode.sound, no-legacy-javascript, new-holders, csp), the Dart to JavaScript compiler version: 2.15.0.
self.$__dart_deferred_initializers__ = self.$__dart_deferred_initializers__ || Object.create(null);
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var A = {nullFuture_closure: function nullFuture_closure() {
    },
    StreamController_StreamController(onCancel, onListen, sync, $T) {
      var _null = null;
      return sync ? new A._SyncStreamController(onListen, _null, _null, onCancel, $T._eval$1("_SyncStreamController<0>")) : new A._AsyncStreamController(onListen, _null, _null, onCancel, $T._eval$1("_AsyncStreamController<0>"));
    },
    _runGuarded(notificationHandler) {
      var e, s, exception, t1, t2;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = B.unwrapException(exception);
        s = B.getTraceFromException(exception);
        t1 = type$.Object._as(e);
        t2 = type$.StackTrace._as(s);
        B._rootHandleError(t1, t2);
      }
    },
    _BufferingStreamSubscription__registerDataHandler(zone, handleData, $T) {
      var t1 = handleData == null ? A.async___nullDataHandler$closure() : handleData;
      return type$.$env_1_1_void._bind$1($T)._eval$1("1(2)")._as(t1);
    },
    _BufferingStreamSubscription__registerErrorHandler(zone, handleError) {
      if (handleError == null)
        handleError = A.async___nullErrorHandler$closure();
      if (type$.void_Function_Object_StackTrace._is(handleError))
        return zone.registerBinaryCallback$3$1(handleError, type$.dynamic, type$.Object, type$.StackTrace);
      if (type$.void_Function_Object._is(handleError))
        return type$.dynamic_Function_Object._as(handleError);
      throw B.wrapException(B.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace.", null));
    },
    _nullDataHandler(value) {
    },
    _nullErrorHandler(error, stackTrace) {
      B._rootHandleError(error, stackTrace);
    },
    _nullDoneHandler() {
    },
    _cancelAndValue(subscription, future, value) {
      var cancelFuture = subscription.cancel$0(),
        t1 = $.$get$Future__nullFuture();
      if (cancelFuture !== t1)
        cancelFuture.whenComplete$1(new A._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    },
    Stream: function Stream() {
    },
    Stream_length_closure: function Stream_length_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    Stream_length_closure0: function Stream_length_closure0(t0, t1) {
      this._box_0 = t0;
      this.future = t1;
    },
    Stream_first_closure: function Stream_first_closure(t0) {
      this.future = t0;
    },
    Stream_first_closure0: function Stream_first_closure0(t0, t1, t2) {
      this.$this = t0;
      this.subscription = t1;
      this.future = t2;
    },
    StreamTransformerBase: function StreamTransformerBase() {
    },
    _StreamController: function _StreamController() {
    },
    _StreamController__subscribe_closure: function _StreamController__subscribe_closure(t0) {
      this.$this = t0;
    },
    _StreamController__recordCancel_complete: function _StreamController__recordCancel_complete(t0) {
      this.$this = t0;
    },
    _SyncStreamControllerDispatch: function _SyncStreamControllerDispatch() {
    },
    _AsyncStreamControllerDispatch: function _AsyncStreamControllerDispatch() {
    },
    _AsyncStreamController: function _AsyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _SyncStreamController: function _SyncStreamController(t0, t1, t2, t3, t4) {
      var _ = this;
      _._varData = null;
      _._state = 0;
      _._doneFuture = null;
      _.onListen = t0;
      _.onPause = t1;
      _.onResume = t2;
      _.onCancel = t3;
      _.$ti = t4;
    },
    _ControllerStream: function _ControllerStream(t0, t1) {
      this._controller = t0;
      this.$ti = t1;
    },
    _ControllerSubscription: function _ControllerSubscription(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._controller = t0;
      _._onData = t1;
      _._onError = t2;
      _._onDone = t3;
      _._zone = t4;
      _._state = t5;
      _._pending = _._cancelFuture = null;
      _.$ti = t6;
    },
    _StreamSinkWrapper: function _StreamSinkWrapper(t0, t1) {
      this._target = t0;
      this.$ti = t1;
    },
    _BufferingStreamSubscription: function _BufferingStreamSubscription() {
    },
    _BufferingStreamSubscription__sendError_sendError: function _BufferingStreamSubscription__sendError_sendError(t0, t1, t2) {
      this.$this = t0;
      this.error = t1;
      this.stackTrace = t2;
    },
    _BufferingStreamSubscription__sendDone_sendDone: function _BufferingStreamSubscription__sendDone_sendDone(t0) {
      this.$this = t0;
    },
    _StreamImpl: function _StreamImpl() {
    },
    _DelayedEvent: function _DelayedEvent() {
    },
    _DelayedData: function _DelayedData(t0, t1) {
      this.value = t0;
      this.next = null;
      this.$ti = t1;
    },
    _DelayedError: function _DelayedError(t0, t1) {
      this.error = t0;
      this.stackTrace = t1;
      this.next = null;
    },
    _DelayedDone: function _DelayedDone() {
    },
    _PendingEvents: function _PendingEvents() {
    },
    _PendingEvents_schedule_closure: function _PendingEvents_schedule_closure(t0, t1) {
      this.$this = t0;
      this.dispatch = t1;
    },
    _StreamImplEvents: function _StreamImplEvents(t0) {
      var _ = this;
      _.lastPendingEvent = _.firstPendingEvent = null;
      _._state = 0;
      _.$ti = t0;
    },
    _cancelAndValue_closure: function _cancelAndValue_closure(t0, t1) {
      this.future = t0;
      this.value = t1;
    },
    _Base64Encoder_encodeChunk(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
      var t1, t2, i, byteOr, byte, outputIndex0, t3, outputIndex1,
        bits = state >>> 2,
        expectedChars = 3 - (state & 3);
      for (t1 = bytes.length, t2 = output.length, i = start, byteOr = 0; i < end; ++i) {
        if (!(i < t1))
          return B.ioore(bytes, i);
        byte = bytes[i];
        byteOr = (byteOr | byte) >>> 0;
        bits = (bits << 8 | byte) & 16777215;
        --expectedChars;
        if (expectedChars === 0) {
          outputIndex0 = outputIndex + 1;
          t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 18 & 63);
          if (!(outputIndex < t2))
            return B.ioore(output, outputIndex);
          output[outputIndex] = t3;
          outputIndex = outputIndex0 + 1;
          t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 12 & 63);
          if (!(outputIndex0 < t2))
            return B.ioore(output, outputIndex0);
          output[outputIndex0] = t3;
          outputIndex0 = outputIndex + 1;
          t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 6 & 63);
          if (!(outputIndex < t2))
            return B.ioore(output, outputIndex);
          output[outputIndex] = t3;
          outputIndex = outputIndex0 + 1;
          t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits & 63);
          if (!(outputIndex0 < t2))
            return B.ioore(output, outputIndex0);
          output[outputIndex0] = t3;
          bits = 0;
          expectedChars = 3;
        }
      }
      if (byteOr >= 0 && byteOr <= 255) {
        if (isLast && expectedChars < 3) {
          outputIndex0 = outputIndex + 1;
          outputIndex1 = outputIndex0 + 1;
          if (3 - expectedChars === 1) {
            t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 2 & 63);
            if (!(outputIndex < t2))
              return B.ioore(output, outputIndex);
            output[outputIndex] = t1;
            t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 4 & 63);
            if (!(outputIndex0 < t2))
              return B.ioore(output, outputIndex0);
            output[outputIndex0] = t1;
            outputIndex = outputIndex1 + 1;
            if (!(outputIndex1 < t2))
              return B.ioore(output, outputIndex1);
            output[outputIndex1] = 61;
            if (!(outputIndex < t2))
              return B.ioore(output, outputIndex);
            output[outputIndex] = 61;
          } else {
            t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 10 & 63);
            if (!(outputIndex < t2))
              return B.ioore(output, outputIndex);
            output[outputIndex] = t1;
            t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 4 & 63);
            if (!(outputIndex0 < t2))
              return B.ioore(output, outputIndex0);
            output[outputIndex0] = t1;
            outputIndex = outputIndex1 + 1;
            t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 2 & 63);
            if (!(outputIndex1 < t2))
              return B.ioore(output, outputIndex1);
            output[outputIndex1] = t1;
            if (!(outputIndex < t2))
              return B.ioore(output, outputIndex);
            output[outputIndex] = 61;
          }
          return 0;
        }
        return (bits << 2 | 3 - expectedChars) >>> 0;
      }
      for (i = start; i < end;) {
        if (!(i < t1))
          return B.ioore(bytes, i);
        byte = bytes[i];
        if (byte < 0 || byte > 255)
          break;
        ++i;
      }
      t1 = "Not a byte value at index " + i + ": 0x";
      if (!(i < bytes.length))
        return B.ioore(bytes, i);
      throw B.wrapException(B.ArgumentError$value(bytes, t1 + J.toRadixString$1$n(bytes[i], 16), null));
    },
    Base64Codec: function Base64Codec() {
    },
    Base64Encoder: function Base64Encoder() {
    },
    _Base64Encoder: function _Base64Encoder(t0) {
      this._convert$_state = 0;
      this._alphabet = t0;
    },
    Codec: function Codec() {
    },
    Converter: function Converter() {
    },
    MyWorker: function MyWorker() {
    },
    _myMessageImplFromMap(map) {
      var result = B._asStringQ(map.$index(0, "result"));
      if (result != null)
        return {result: result};
      return {data: type$.Uint8List._as(map.$index(0, "data"))};
    },
    MyWorkerImpl$() {
      return new A.MyWorkerImpl(new B._AsyncCompleter(new B._Future($.Zone__current, type$._Future_void), type$._AsyncCompleter_void));
    },
    MyWorkerImpl: function MyWorkerImpl(t0) {
      this.ready = t0;
    },
    MyWorkerImpl_connect_closure: function MyWorkerImpl_connect_closure(t0) {
      this.channel = t0;
    },
    MyWorkerImpl_connect_closure0: function MyWorkerImpl_connect_closure0() {
    },
    GuaranteeChannel$(innerStream, innerSink, allowSinkErrors, $T) {
      var t2, t1 = {};
      t1.innerStream = innerStream;
      t2 = new A.GuaranteeChannel($T._eval$1("GuaranteeChannel<0>"));
      t2.GuaranteeChannel$3$allowSinkErrors(innerSink, true, t1, $T);
      return t2;
    },
    GuaranteeChannel: function GuaranteeChannel(t0) {
      var _ = this;
      _.__GuaranteeChannel__streamController = _.__GuaranteeChannel__sink = $;
      _._subscription = null;
      _._disconnected = false;
      _.$ti = t0;
    },
    GuaranteeChannel_closure: function GuaranteeChannel_closure(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.T = t2;
    },
    GuaranteeChannel__closure: function GuaranteeChannel__closure(t0) {
      this.$this = t0;
    },
    _GuaranteeSink: function _GuaranteeSink(t0, t1, t2, t3, t4) {
      var _ = this;
      _._inner = t0;
      _._channel = t1;
      _._doneCompleter = t2;
      _._closed = _._disconnected = false;
      _._addStreamCompleter = _._addStreamSubscription = null;
      _._allowErrors = t3;
      _.$ti = t4;
    },
    StreamChannelController: function StreamChannelController(t0) {
      this.__StreamChannelController__foreign = this.__StreamChannelController__local = $;
      this.$ti = t0;
    },
    StreamChannelMixin: function StreamChannelMixin() {
    },
    WorkerBeeBase: function WorkerBeeBase() {
    },
    _WorkerBeeBase_Object_StreamChannelMixin: function _WorkerBeeBase_Object_StreamChannelMixin() {
    },
    Primitives_stringFromNativeUint8List(charCodes, start, end) {
      var i, result, i0, chunkEnd;
      if (end <= 500 && start === 0 && end === charCodes.length)
        return String.fromCharCode.apply(null, charCodes);
      for (i = start, result = ""; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    _lateReadCheck(value, $name) {
      if (value === $)
        throw B.wrapException(new B.LateError("Field '" + $name + "' has not been initialized."));
      return value;
    },
    _lateWriteOnceCheck(value, $name) {
      if (value !== $)
        throw B.wrapException(new B.LateError("Field '" + $name + "' has already been initialized."));
    },
    String_String$fromCharCodes(charCodes) {
      var t1 = A.Primitives_stringFromNativeUint8List(charCodes, 0, B.RangeError_checkValidRange(0, null, charCodes.length));
      return t1;
    }
  },
  B, D, C, J;
  hunkHelpers.setFunctionNamesIfNecessary([A]);
  A = hunkHelpers.updateHolder(holdersList[3], A);
  B = holdersList[0];
  D = holdersList[4];
  C = holdersList[2];
  J = holdersList[1];
  A.Stream.prototype = {
    get$length(_) {
      var t1 = {},
        future = new B._Future($.Zone__current, type$._Future_int);
      t1.count = 0;
      this.listen$4$cancelOnError$onDone$onError(new A.Stream_length_closure(t1, this), true, new A.Stream_length_closure0(t1, future), future.get$_completeError());
      return future;
    },
    get$first(_) {
      var future = new B._Future($.Zone__current, B._instanceType(this)._eval$1("_Future<Stream.T>")),
        subscription = this.listen$4$cancelOnError$onDone$onError(null, true, new A.Stream_first_closure(future), future.get$_completeError()),
        t1 = B._instanceType(subscription);
      subscription.set$_onData(A._BufferingStreamSubscription__registerDataHandler(subscription._zone, t1._eval$1("~(_BufferingStreamSubscription.T)?")._as(new A.Stream_first_closure0(this, subscription, future)), t1._eval$1("_BufferingStreamSubscription.T")));
      return future;
    }
  };
  A.StreamTransformerBase.prototype = {$isStreamTransformer: 1};
  A._StreamController.prototype = {
    get$_pendingEvents() {
      var t1, _this = this;
      if ((_this._state & 8) === 0)
        return B._instanceType(_this)._eval$1("_PendingEvents<1>?")._as(_this._varData);
      t1 = B._instanceType(_this);
      return t1._eval$1("_PendingEvents<1>?")._as(t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$varData());
    },
    _ensurePendingEvents$0() {
      var events, t1, _this = this;
      if ((_this._state & 8) === 0) {
        events = _this._varData;
        if (events == null)
          events = _this._varData = new A._StreamImplEvents(B._instanceType(_this)._eval$1("_StreamImplEvents<1>"));
        return B._instanceType(_this)._eval$1("_StreamImplEvents<1>")._as(events);
      }
      t1 = B._instanceType(_this);
      events = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).get$varData();
      return t1._eval$1("_StreamImplEvents<1>")._as(events);
    },
    get$_async$_subscription() {
      var varData = this._varData;
      if ((this._state & 8) !== 0)
        varData = type$._StreamControllerAddStreamState_nullable_Object._as(varData).get$varData();
      return B._instanceType(this)._eval$1("_ControllerSubscription<1>")._as(varData);
    },
    _badEventState$0() {
      if ((this._state & 4) !== 0)
        return new B.StateError("Cannot add event after closing");
      return new B.StateError("Cannot add event while adding a stream");
    },
    _ensureDoneFuture$0() {
      var t1 = this._doneFuture;
      if (t1 == null)
        t1 = this._doneFuture = (this._state & 2) !== 0 ? $.$get$Future__nullFuture() : new B._Future($.Zone__current, type$._Future_void);
      return t1;
    },
    add$1(_, value) {
      var t2, _this = this,
        t1 = B._instanceType(_this);
      t1._precomputed1._as(value);
      t2 = _this._state;
      if (t2 >= 4)
        throw B.wrapException(_this._badEventState$0());
      if ((t2 & 1) !== 0)
        _this._sendData$1(value);
      else if ((t2 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new A._DelayedData(value, t1._eval$1("_DelayedData<1>")));
    },
    addError$2(error, stackTrace) {
      var _this = this,
        t1 = type$.Object;
      t1._as(error);
      type$.nullable_StackTrace._as(stackTrace);
      B.checkNotNullable(error, "error", t1);
      if (_this._state >= 4)
        throw B.wrapException(_this._badEventState$0());
      if (stackTrace == null)
        stackTrace = B.AsyncError_defaultStackTrace(error);
      t1 = _this._state;
      if ((t1 & 1) !== 0)
        _this._sendError$2(error, stackTrace);
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, new A._DelayedError(error, stackTrace));
    },
    addError$1(error) {
      return this.addError$2(error, null);
    },
    close$0(_) {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 4) !== 0)
        return _this._ensureDoneFuture$0();
      if (t1 >= 4)
        throw B.wrapException(_this._badEventState$0());
      t1 = _this._state = t1 | 4;
      if ((t1 & 1) !== 0)
        _this._sendDone$0();
      else if ((t1 & 3) === 0)
        _this._ensurePendingEvents$0().add$1(0, D.C__DelayedDone);
      return _this._ensureDoneFuture$0();
    },
    _subscribe$4(onData, onError, onDone, cancelOnError) {
      var t2, t3, t4, t5, t6, subscription, pendingEvents, addState, _this = this,
        t1 = B._instanceType(_this);
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      if ((_this._state & 3) !== 0)
        throw B.wrapException(B.StateError$("Stream has already been listened to."));
      t2 = $.Zone__current;
      t3 = cancelOnError ? 1 : 0;
      t4 = A._BufferingStreamSubscription__registerDataHandler(t2, onData, t1._precomputed1);
      t5 = A._BufferingStreamSubscription__registerErrorHandler(t2, onError);
      t6 = onDone == null ? A.async___nullDoneHandler$closure() : onDone;
      subscription = new A._ControllerSubscription(_this, t4, t5, type$.void_Function._as(t6), t2, t3, t1._eval$1("_ControllerSubscription<1>"));
      pendingEvents = _this.get$_pendingEvents();
      t3 = _this._state |= 1;
      if ((t3 & 8) !== 0) {
        addState = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData);
        addState.set$varData(subscription);
        addState.resume$0();
      } else
        _this._varData = subscription;
      subscription._setPendingEvents$1(pendingEvents);
      subscription._guardCallback$1(new A._StreamController__subscribe_closure(_this));
      return subscription;
    },
    _recordCancel$1(subscription) {
      var result, onCancel, cancelResult, e, s, exception, result0, _this = this,
        t1 = B._instanceType(_this);
      t1._eval$1("StreamSubscription<1>")._as(subscription);
      result = null;
      if ((_this._state & 8) !== 0)
        result = t1._eval$1("_StreamControllerAddStreamState<1>")._as(_this._varData).cancel$0();
      _this._varData = null;
      _this._state = _this._state & 4294967286 | 2;
      onCancel = _this.onCancel;
      if (onCancel != null)
        if (result == null)
          try {
            cancelResult = onCancel.call$0();
            if (type$.Future_void._is(cancelResult))
              result = cancelResult;
          } catch (exception) {
            e = B.unwrapException(exception);
            s = B.getTraceFromException(exception);
            result0 = new B._Future($.Zone__current, type$._Future_void);
            result0._asyncCompleteError$2(e, s);
            result = result0;
          }
        else
          result = result.whenComplete$1(onCancel);
      t1 = new A._StreamController__recordCancel_complete(_this);
      if (result != null)
        result = result.whenComplete$1(t1);
      else
        t1.call$0();
      return result;
    },
    $isStreamSink: 1,
    $isStreamController: 1,
    $is_StreamControllerLifecycle: 1,
    $is_EventDispatch: 1
  };
  A._SyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      this.$ti._precomputed1._as(data);
      this.get$_async$_subscription()._add$1(data);
    },
    _sendError$2(error, stackTrace) {
      this.get$_async$_subscription()._addError$2(error, stackTrace);
    },
    _sendDone$0() {
      this.get$_async$_subscription()._close$0();
    }
  };
  A._AsyncStreamControllerDispatch.prototype = {
    _sendData$1(data) {
      var t1 = this.$ti;
      t1._precomputed1._as(data);
      this.get$_async$_subscription()._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<1>")));
    },
    _sendError$2(error, stackTrace) {
      this.get$_async$_subscription()._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _sendDone$0() {
      this.get$_async$_subscription()._addPending$1(D.C__DelayedDone);
    }
  };
  A._AsyncStreamController.prototype = {};
  A._SyncStreamController.prototype = {};
  A._ControllerStream.prototype = {
    get$hashCode(_) {
      return (B.Primitives_objectHashCode(this._controller) ^ 892482866) >>> 0;
    },
    $eq(_, other) {
      if (other == null)
        return false;
      if (this === other)
        return true;
      return other instanceof A._ControllerStream && other._controller === this._controller;
    }
  };
  A._ControllerSubscription.prototype = {
    _onCancel$0() {
      return this._controller._recordCancel$1(this);
    },
    _onPause$0() {
      var t1 = this._controller,
        t2 = B._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).pause$0();
      A._runGuarded(t1.onPause);
    },
    _onResume$0() {
      var t1 = this._controller,
        t2 = B._instanceType(t1);
      t2._eval$1("StreamSubscription<1>")._as(this);
      if ((t1._state & 8) !== 0)
        t2._eval$1("_StreamControllerAddStreamState<1>")._as(t1._varData).resume$0();
      A._runGuarded(t1.onResume);
    }
  };
  A._StreamSinkWrapper.prototype = {$isStreamSink: 1};
  A._BufferingStreamSubscription.prototype = {
    _setPendingEvents$1(pendingEvents) {
      var _this = this;
      B._instanceType(_this)._eval$1("_PendingEvents<_BufferingStreamSubscription.T>?")._as(pendingEvents);
      if (pendingEvents == null)
        return;
      _this.set$_pending(pendingEvents);
      if (pendingEvents.lastPendingEvent != null) {
        _this._state = (_this._state | 64) >>> 0;
        pendingEvents.schedule$1(_this);
      }
    },
    cancel$0() {
      var _this = this,
        t1 = (_this._state & 4294967279) >>> 0;
      _this._state = t1;
      if ((t1 & 8) === 0)
        _this._cancel$0();
      t1 = _this._cancelFuture;
      return t1 == null ? $.$get$Future__nullFuture() : t1;
    },
    _cancel$0() {
      var t2, _this = this,
        t1 = _this._state = (_this._state | 8) >>> 0;
      if ((t1 & 64) !== 0) {
        t2 = _this._pending;
        if (t2._state === 1)
          t2._state = 3;
      }
      if ((t1 & 32) === 0)
        _this.set$_pending(null);
      _this._cancelFuture = _this._onCancel$0();
    },
    _add$1(data) {
      var t2, _this = this,
        t1 = B._instanceType(_this);
      t1._eval$1("_BufferingStreamSubscription.T")._as(data);
      t2 = _this._state;
      if ((t2 & 8) !== 0)
        return;
      if (t2 < 32)
        _this._sendData$1(data);
      else
        _this._addPending$1(new A._DelayedData(data, t1._eval$1("_DelayedData<_BufferingStreamSubscription.T>")));
    },
    _addError$2(error, stackTrace) {
      var t1 = this._state;
      if ((t1 & 8) !== 0)
        return;
      if (t1 < 32)
        this._sendError$2(error, stackTrace);
      else
        this._addPending$1(new A._DelayedError(error, stackTrace));
    },
    _close$0() {
      var _this = this,
        t1 = _this._state;
      if ((t1 & 8) !== 0)
        return;
      t1 = (t1 | 2) >>> 0;
      _this._state = t1;
      if (t1 < 32)
        _this._sendDone$0();
      else
        _this._addPending$1(D.C__DelayedDone);
    },
    _onPause$0() {
    },
    _onResume$0() {
    },
    _onCancel$0() {
      return null;
    },
    _addPending$1($event) {
      var _this = this,
        t1 = B._instanceType(_this),
        pending = t1._eval$1("_StreamImplEvents<_BufferingStreamSubscription.T>?")._as(_this._pending);
      if (pending == null)
        pending = new A._StreamImplEvents(t1._eval$1("_StreamImplEvents<_BufferingStreamSubscription.T>"));
      _this.set$_pending(pending);
      pending.add$1(0, $event);
      t1 = _this._state;
      if ((t1 & 64) === 0) {
        t1 = (t1 | 64) >>> 0;
        _this._state = t1;
        if (t1 < 128)
          pending.schedule$1(_this);
      }
    },
    _sendData$1(data) {
      var t2, _this = this,
        t1 = B._instanceType(_this)._eval$1("_BufferingStreamSubscription.T");
      t1._as(data);
      t2 = _this._state;
      _this._state = (t2 | 32) >>> 0;
      _this._zone.runUnaryGuarded$1$2(_this._onData, data, t1);
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t2 & 4) !== 0);
    },
    _sendError$2(error, stackTrace) {
      var cancelFuture, _this = this,
        t1 = _this._state,
        t2 = new A._BufferingStreamSubscription__sendError_sendError(_this, error, stackTrace);
      if ((t1 & 1) !== 0) {
        _this._state = (t1 | 16) >>> 0;
        _this._cancel$0();
        cancelFuture = _this._cancelFuture;
        if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
          cancelFuture.whenComplete$1(t2);
        else
          t2.call$0();
      } else {
        t2.call$0();
        _this._checkState$1((t1 & 4) !== 0);
      }
    },
    _sendDone$0() {
      var cancelFuture, _this = this,
        t1 = new A._BufferingStreamSubscription__sendDone_sendDone(_this);
      _this._cancel$0();
      _this._state = (_this._state | 16) >>> 0;
      cancelFuture = _this._cancelFuture;
      if (cancelFuture != null && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(t1);
      else
        t1.call$0();
    },
    _guardCallback$1(callback) {
      var t1, _this = this;
      type$.void_Function._as(callback);
      t1 = _this._state;
      _this._state = (t1 | 32) >>> 0;
      callback.call$0();
      _this._state = (_this._state & 4294967263) >>> 0;
      _this._checkState$1((t1 & 4) !== 0);
    },
    _checkState$1(wasInputPaused) {
      var t2, isInputPaused, _this = this,
        t1 = _this._state;
      if ((t1 & 64) !== 0 && _this._pending.lastPendingEvent == null) {
        t1 = _this._state = (t1 & 4294967231) >>> 0;
        if ((t1 & 4) !== 0)
          if (t1 < 128) {
            t2 = _this._pending;
            t2 = t2 == null ? null : t2.lastPendingEvent == null;
            t2 = t2 !== false;
          } else
            t2 = false;
        else
          t2 = false;
        if (t2) {
          t1 = (t1 & 4294967291) >>> 0;
          _this._state = t1;
        }
      }
      for (; true; wasInputPaused = isInputPaused) {
        if ((t1 & 8) !== 0) {
          _this.set$_pending(null);
          return;
        }
        isInputPaused = (t1 & 4) !== 0;
        if (wasInputPaused === isInputPaused)
          break;
        _this._state = (t1 ^ 32) >>> 0;
        if (isInputPaused)
          _this._onPause$0();
        else
          _this._onResume$0();
        t1 = (_this._state & 4294967263) >>> 0;
        _this._state = t1;
      }
      if ((t1 & 64) !== 0 && t1 < 128)
        _this._pending.schedule$1(_this);
    },
    set$_onData(_onData) {
      this._onData = B._instanceType(this)._eval$1("~(_BufferingStreamSubscription.T)")._as(_onData);
    },
    set$_pending(_pending) {
      this._pending = B._instanceType(this)._eval$1("_PendingEvents<_BufferingStreamSubscription.T>?")._as(_pending);
    },
    $isStreamSubscription: 1,
    $is_EventDispatch: 1
  };
  A._StreamImpl.prototype = {
    listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError) {
      var t1 = this.$ti;
      t1._eval$1("~(1)?")._as(onData);
      type$.nullable_void_Function._as(onDone);
      return this._controller._subscribe$4(t1._eval$1("~(1)?")._as(onData), onError, onDone, cancelOnError === true);
    },
    listen$1(onData) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
    },
    listen$3$onDone$onError(onData, onDone, onError) {
      return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
    }
  };
  A._DelayedEvent.prototype = {
    set$next(next) {
      this.next = type$.nullable__DelayedEvent_dynamic._as(next);
    },
    get$next() {
      return this.next;
    }
  };
  A._DelayedData.prototype = {
    perform$1(dispatch) {
      this.$ti._eval$1("_EventDispatch<1>")._as(dispatch)._sendData$1(this.value);
    }
  };
  A._DelayedError.prototype = {
    perform$1(dispatch) {
      dispatch._sendError$2(this.error, this.stackTrace);
    }
  };
  A._DelayedDone.prototype = {
    perform$1(dispatch) {
      dispatch._sendDone$0();
    },
    get$next() {
      return null;
    },
    set$next(_) {
      throw B.wrapException(B.StateError$("No events after a done."));
    },
    $is_DelayedEvent: 1
  };
  A._PendingEvents.prototype = {
    schedule$1(dispatch) {
      var t1, _this = this;
      _this.$ti._eval$1("_EventDispatch<1>")._as(dispatch);
      t1 = _this._state;
      if (t1 === 1)
        return;
      if (t1 >= 1) {
        _this._state = 1;
        return;
      }
      B.scheduleMicrotask(new A._PendingEvents_schedule_closure(_this, dispatch));
      _this._state = 1;
    }
  };
  A._StreamImplEvents.prototype = {
    add$1(_, $event) {
      var _this = this,
        lastEvent = _this.lastPendingEvent;
      if (lastEvent == null)
        _this.firstPendingEvent = _this.lastPendingEvent = $event;
      else {
        lastEvent.set$next($event);
        _this.lastPendingEvent = $event;
      }
    }
  };
  A.Base64Codec.prototype = {};
  A.Base64Encoder.prototype = {
    convert$1(input) {
      var t1;
      type$.List_int._as(input);
      t1 = input.length;
      if (t1 === 0)
        return "";
      t1 = new A._Base64Encoder("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").encode$4(input, 0, t1, true);
      t1.toString;
      return A.String_String$fromCharCodes(t1);
    }
  };
  A._Base64Encoder.prototype = {
    createBuffer$1(bufferLength) {
      return new Uint8Array(bufferLength);
    },
    encode$4(bytes, start, end, isLast) {
      var byteCount, fullChunks, bufferLength, output, _this = this;
      type$.List_int._as(bytes);
      byteCount = (_this._convert$_state & 3) + (end - start);
      fullChunks = C.JSInt_methods._tdivFast$1(byteCount, 3);
      bufferLength = fullChunks * 4;
      if (isLast && byteCount - fullChunks * 3 > 0)
        bufferLength += 4;
      output = _this.createBuffer$1(bufferLength);
      _this._convert$_state = A._Base64Encoder_encodeChunk(_this._alphabet, bytes, start, end, isLast, output, 0, _this._convert$_state);
      if (bufferLength > 0)
        return output;
      return null;
    }
  };
  A.Codec.prototype = {};
  A.Converter.prototype = {};
  A.MyWorker.prototype = {
    run$2(listen, respond) {
      return this.run$body$MyWorker(type$.Stream_MyMessage._as(listen), type$.StreamSink_MyMessage._as(respond));
    },
    run$body$MyWorker(listen, respond) {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.String),
        $async$returnValue, $async$temp1, $async$temp2, $async$temp3;
      var $async$run$2 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$temp1 = D.C_Base64Encoder;
              $async$temp2 = type$.Base64Codec._eval$1("Codec.S");
              $async$temp3 = J;
              $async$goto = 3;
              return B._asyncAwait(listen.get$first(listen), $async$run$2);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.convert$1($async$temp2._as($async$temp3.get$data$x($async$result)));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return B._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return B._asyncStartSync($async$run$2, $async$completer);
    }
  };
  A.MyWorkerImpl.prototype = {
    connect$0() {
      var $async$goto = 0,
        $async$completer = B._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, channel, t1, localToForeignController, foreignToLocalController, t2, t3, t4, t5, result;
      var $async$connect$0 = B._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return B._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              B.print("(Worker) Connecting from worker...");
              channel = new A.StreamChannelController(type$.StreamChannelController_MyMessage);
              t1 = type$.MyMessage;
              localToForeignController = A.StreamController_StreamController(null, null, false, t1);
              foreignToLocalController = A.StreamController_StreamController(null, null, false, t1);
              t2 = B._instanceType(foreignToLocalController);
              t3 = B._instanceType(localToForeignController);
              t4 = type$.StreamChannel_MyMessage;
              t5 = t4._as(A.GuaranteeChannel$(new A._ControllerStream(foreignToLocalController, t2._eval$1("_ControllerStream<1>")), new A._StreamSinkWrapper(localToForeignController, t3._eval$1("_StreamSinkWrapper<1>")), true, t1));
              A._lateWriteOnceCheck($, "_local");
              channel.set$__StreamChannelController__local(t5);
              t1 = t4._as(A.GuaranteeChannel$(new A._ControllerStream(localToForeignController, t3._eval$1("_ControllerStream<1>")), new A._StreamSinkWrapper(foreignToLocalController, t2._eval$1("_StreamSinkWrapper<1>")), true, t1));
              A._lateWriteOnceCheck(channel.__StreamChannelController__foreign, "_foreign");
              channel.set$__StreamChannelController__foreign(t1);
              t1 = self;
              t1.toString;
              J.addEventListener$2$x(t1, "message", new A.MyWorkerImpl_connect_closure(channel));
              t1 = A._lateReadCheck(A._lateReadCheck(channel.__StreamChannelController__foreign, "_foreign").__GuaranteeChannel__streamController, "_streamController");
              new A._ControllerStream(t1, B._instanceType(t1)._eval$1("_ControllerStream<1>")).listen$1(new A.MyWorkerImpl_connect_closure0());
              B.print("(Worker) Sending ready event");
              self.postMessage("ready");
              t1 = A._lateReadCheck(A._lateReadCheck(channel.__StreamChannelController__local, "_local").__GuaranteeChannel__streamController, "_streamController");
              $async$goto = 2;
              return B._asyncAwait($async$self.run$2(new A._ControllerStream(t1, B._instanceType(t1)._eval$1("_ControllerStream<1>")), A._lateReadCheck(A._lateReadCheck(channel.__StreamChannelController__local, "_local").__GuaranteeChannel__sink, "_sink")), $async$connect$0);
            case 2:
              // returning from await.
              result = $async$result;
              B.print("(Worker) Finished with result: " + result);
              self.postMessage({result: result});
              // implicit return
              return B._asyncReturn(null, $async$completer);
          }
      });
      return B._asyncStartSync($async$connect$0, $async$completer);
    }
  };
  A.GuaranteeChannel.prototype = {
    GuaranteeChannel$3$allowSinkErrors(innerSink, allowSinkErrors, _box_0, $T) {
      var _this = this,
        t1 = _this.$ti,
        t2 = t1._eval$1("_GuaranteeSink<1>")._as(new A._GuaranteeSink(innerSink, _this, new B._AsyncCompleter(new B._Future($.Zone__current, type$._Future_dynamic), type$._AsyncCompleter_dynamic), true, $T._eval$1("_GuaranteeSink<0>")));
      A._lateWriteOnceCheck(_this.__GuaranteeChannel__sink, "_sink");
      _this.set$__GuaranteeChannel__sink(t2);
      t1 = t1._eval$1("StreamController<1>")._as(A.StreamController_StreamController(null, new A.GuaranteeChannel_closure(_box_0, _this, $T), true, $T));
      A._lateWriteOnceCheck(_this.__GuaranteeChannel__streamController, "_streamController");
      _this.set$__GuaranteeChannel__streamController(t1);
    },
    set$__GuaranteeChannel__sink(__GuaranteeChannel__sink) {
      this.__GuaranteeChannel__sink = this.$ti._eval$1("_GuaranteeSink<1>")._as(__GuaranteeChannel__sink);
    },
    set$__GuaranteeChannel__streamController(__GuaranteeChannel__streamController) {
      this.__GuaranteeChannel__streamController = this.$ti._eval$1("StreamController<1>")._as(__GuaranteeChannel__streamController);
    },
    set$_subscription(_subscription) {
      this._subscription = this.$ti._eval$1("StreamSubscription<1>?")._as(_subscription);
    }
  };
  A._GuaranteeSink.prototype = {
    add$1(_, data) {
      var t1, _this = this;
      _this.$ti._precomputed1._as(data);
      if (_this._closed)
        throw B.wrapException(B.StateError$("Cannot add event after closing."));
      if (_this._disconnected)
        return;
      t1 = _this._inner;
      t1._target.add$1(0, t1.$ti._precomputed1._as(data));
    },
    _onStreamDisconnected$0() {
      this._disconnected = true;
      var t1 = this._doneCompleter;
      if ((t1.future._state & 30) === 0)
        t1.complete$0();
      return;
    },
    $isStreamSink: 1
  };
  A.StreamChannelController.prototype = {
    set$__StreamChannelController__local(__StreamChannelController__local) {
      this.__StreamChannelController__local = this.$ti._eval$1("StreamChannel<1>")._as(__StreamChannelController__local);
    },
    set$__StreamChannelController__foreign(__StreamChannelController__foreign) {
      this.__StreamChannelController__foreign = this.$ti._eval$1("StreamChannel<1>")._as(__StreamChannelController__foreign);
    }
  };
  A.StreamChannelMixin.prototype = {$isStreamChannel: 1};
  A.WorkerBeeBase.prototype = {$isStreamChannel: 1};
  A._WorkerBeeBase_Object_StreamChannelMixin.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["~(Object?)", "~(Object[StackTrace?])", "~(@)", "~(Object,StackTrace)", "~()"]);
  A.nullFuture_closure.prototype = {
    call$0() {
      return B.Future_Future$value(null, type$.Null);
    },
    $signature: 22
  };
  A.Stream_length_closure.prototype = {
    call$1(_) {
      B._instanceType(this.$this)._eval$1("Stream.T")._as(_);
      ++this._box_0.count;
    },
    $signature() {
      return B._instanceType(this.$this)._eval$1("~(Stream.T)");
    }
  };
  A.Stream_length_closure0.prototype = {
    call$0() {
      this.future._complete$1(this._box_0.count);
    },
    $signature: 0
  };
  A.Stream_first_closure.prototype = {
    call$0() {
      var e, s, t1, exception, stackTrace;
      try {
        t1 = B.IterableElementError_noElement();
        throw B.wrapException(t1);
      } catch (exception) {
        e = B.unwrapException(exception);
        s = B.getTraceFromException(exception);
        t1 = e;
        stackTrace = s;
        if (stackTrace == null)
          stackTrace = B.AsyncError_defaultStackTrace(t1);
        this.future._completeError$2(t1, stackTrace);
      }
    },
    $signature: 0
  };
  A.Stream_first_closure0.prototype = {
    call$1(value) {
      A._cancelAndValue(this.subscription, this.future, B._instanceType(this.$this)._eval$1("Stream.T")._as(value));
    },
    $signature() {
      return B._instanceType(this.$this)._eval$1("~(Stream.T)");
    }
  };
  A._StreamController__subscribe_closure.prototype = {
    call$0() {
      A._runGuarded(this.$this.onListen);
    },
    $signature: 0
  };
  A._StreamController__recordCancel_complete.prototype = {
    call$0() {
      var doneFuture = this.$this._doneFuture;
      if (doneFuture != null && (doneFuture._state & 30) === 0)
        doneFuture._asyncComplete$1(null);
    },
    $signature: 0
  };
  A._BufferingStreamSubscription__sendError_sendError.prototype = {
    call$0() {
      var onError, t3, t4,
        t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 8) !== 0 && (t2 & 16) === 0)
        return;
      t1._state = (t2 | 32) >>> 0;
      onError = t1._onError;
      t2 = this.error;
      t3 = type$.Object;
      t4 = t1._zone;
      if (type$.void_Function_Object_StackTrace._is(onError))
        t4.runBinaryGuarded$2$3(onError, t2, this.stackTrace, t3, type$.StackTrace);
      else
        t4.runUnaryGuarded$1$2(type$.void_Function_Object._as(onError), t2, t3);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 0
  };
  A._BufferingStreamSubscription__sendDone_sendDone.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._state;
      if ((t2 & 16) === 0)
        return;
      t1._state = (t2 | 42) >>> 0;
      t1._zone.runGuarded$1(t1._onDone);
      t1._state = (t1._state & 4294967263) >>> 0;
    },
    $signature: 0
  };
  A._PendingEvents_schedule_closure.prototype = {
    call$0() {
      var t2, $event, nextEvent,
        t1 = this.$this,
        oldState = t1._state;
      t1._state = 0;
      if (oldState === 3)
        return;
      t2 = t1.$ti._eval$1("_EventDispatch<1>")._as(this.dispatch);
      $event = t1.firstPendingEvent;
      nextEvent = $event.get$next();
      t1.firstPendingEvent = nextEvent;
      if (nextEvent == null)
        t1.lastPendingEvent = null;
      $event.perform$1(t2);
    },
    $signature: 0
  };
  A._cancelAndValue_closure.prototype = {
    call$0() {
      return this.future._complete$1(this.value);
    },
    $signature: 0
  };
  A.MyWorkerImpl_connect_closure.prototype = {
    call$1($event) {
      var message;
      $event = type$.MessageEvent._as(type$.Event._as($event));
      B.print("(Worker) Got message from main: " + B.S(new B._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy($event.data, true)));
      message = A._myMessageImplFromMap(type$.Map_dynamic_dynamic._as(new B._AcceptStructuredCloneDart2Js([], []).convertNativeToDart_AcceptStructuredClone$2$mustCopy($event.data, true)));
      A._lateReadCheck(A._lateReadCheck(this.channel.__StreamChannelController__foreign, "_foreign").__GuaranteeChannel__sink, "_sink").add$1(0, message);
    },
    $signature: 7
  };
  A.MyWorkerImpl_connect_closure0.prototype = {
    call$1(message) {
      type$.MyMessage._as(message);
      B.print("(Worker) Sending message to main: " + B.S(J.get$data$x(message)));
      self.postMessage(message);
    },
    $signature: 23
  };
  A.GuaranteeChannel_closure.prototype = {
    call$0() {
      var t2, t3,
        _s17_ = "_streamController",
        t1 = this.$this;
      if (t1._disconnected)
        return;
      t2 = this._box_0.innerStream;
      t3 = A._lateReadCheck(t1.__GuaranteeChannel__streamController, _s17_);
      t1.set$_subscription(t2.listen$3$onDone$onError(this.T._eval$1("~(0)")._as(t3.get$add(t3)), new A.GuaranteeChannel__closure(t1), A._lateReadCheck(t1.__GuaranteeChannel__streamController, _s17_).get$addError()));
    },
    $signature: 0
  };
  A.GuaranteeChannel__closure.prototype = {
    call$0() {
      var t1 = this.$this;
      A._lateReadCheck(t1.__GuaranteeChannel__sink, "_sink")._onStreamDisconnected$0();
      A._lateReadCheck(t1.__GuaranteeChannel__streamController, "_streamController").close$0(0);
    },
    $signature: 0
  };
  (function installTearOffs() {
    var _static_1 = hunkHelpers._static_1,
      _static_2 = hunkHelpers._static_2,
      _static_0 = hunkHelpers._static_0,
      _instance_1_i = hunkHelpers._instance_1i,
      _instance = hunkHelpers.installInstanceTearOff;
    _static_1(A, "async___nullDataHandler$closure", "_nullDataHandler", 2);
    _static_2(A, "async___nullErrorHandler$closure", "_nullErrorHandler", 3);
    _static_0(A, "async___nullDoneHandler$closure", "_nullDoneHandler", 4);
    var _;
    _instance_1_i(_ = A._StreamController.prototype, "get$add", "add$1", 0);
    _instance(_, "get$addError", 0, 1, null, ["call$2", "call$1"], ["addError$2", "addError$1"], 1, 0, 0);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(B.Closure0Args, [A.nullFuture_closure, A.Stream_length_closure0, A.Stream_first_closure, A._StreamController__subscribe_closure, A._StreamController__recordCancel_complete, A._BufferingStreamSubscription__sendError_sendError, A._BufferingStreamSubscription__sendDone_sendDone, A._PendingEvents_schedule_closure, A._cancelAndValue_closure, A.GuaranteeChannel_closure, A.GuaranteeChannel__closure]);
    _inheritMany(B.Object, [A.Stream, A.StreamTransformerBase, A._StreamController, A._SyncStreamControllerDispatch, A._AsyncStreamControllerDispatch, A._BufferingStreamSubscription, A._StreamSinkWrapper, A._DelayedEvent, A._DelayedDone, A._PendingEvents, A.Codec, A._Base64Encoder, A._WorkerBeeBase_Object_StreamChannelMixin, A.StreamChannelMixin, A._GuaranteeSink, A.StreamChannelController]);
    _inheritMany(B.Closure, [A.Stream_length_closure, A.Stream_first_closure0, A.MyWorkerImpl_connect_closure, A.MyWorkerImpl_connect_closure0]);
    _inheritMany(A._StreamController, [A._AsyncStreamController, A._SyncStreamController]);
    _inherit(A._StreamImpl, A.Stream);
    _inherit(A._ControllerStream, A._StreamImpl);
    _inherit(A._ControllerSubscription, A._BufferingStreamSubscription);
    _inheritMany(A._DelayedEvent, [A._DelayedData, A._DelayedError]);
    _inherit(A._StreamImplEvents, A._PendingEvents);
    _inherit(A.Base64Codec, A.Codec);
    _inherit(A.Converter, A.StreamTransformerBase);
    _inherit(A.Base64Encoder, A.Converter);
    _inherit(A.WorkerBeeBase, A._WorkerBeeBase_Object_StreamChannelMixin);
    _inherit(A.MyWorker, A.WorkerBeeBase);
    _inherit(A.MyWorkerImpl, A.MyWorker);
    _inherit(A.GuaranteeChannel, A.StreamChannelMixin);
    _mixin(A._AsyncStreamController, A._AsyncStreamControllerDispatch);
    _mixin(A._SyncStreamController, A._SyncStreamControllerDispatch);
    _mixin(A._WorkerBeeBase_Object_StreamChannelMixin, A.StreamChannelMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"StreamTransformerBase":{"StreamTransformer":["1","2"]},"_StreamController":{"StreamController":["1"],"StreamSink":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_AsyncStreamController":{"_AsyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"StreamSink":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_SyncStreamController":{"_SyncStreamControllerDispatch":["1"],"_StreamController":["1"],"StreamController":["1"],"StreamSink":["1"],"_StreamControllerLifecycle":["1"],"_EventDispatch":["1"]},"_ControllerStream":{"_StreamImpl":["1"],"Stream":["1"],"Stream.T":"1"},"_ControllerSubscription":{"_BufferingStreamSubscription":["1"],"StreamSubscription":["1"],"_EventDispatch":["1"],"_BufferingStreamSubscription.T":"1"},"_StreamSinkWrapper":{"StreamSink":["1"]},"_BufferingStreamSubscription":{"StreamSubscription":["1"],"_EventDispatch":["1"],"_BufferingStreamSubscription.T":"1"},"_StreamImpl":{"Stream":["1"]},"_DelayedData":{"_DelayedEvent":["1"]},"_DelayedError":{"_DelayedEvent":["@"]},"_DelayedDone":{"_DelayedEvent":["@"]},"_StreamImplEvents":{"_PendingEvents":["1"]},"Base64Codec":{"Codec":["List<int>","String"],"Codec.S":"List<int>"},"Base64Encoder":{"Converter":["List<int>","String"],"StreamTransformer":["List<int>","String"]},"Converter":{"StreamTransformer":["1","2"]},"MyWorker":{"WorkerBeeBase":["MyMessage","String"],"StreamChannel":["MyMessage"]},"MyWorkerImpl":{"WorkerBeeBase":["MyMessage","String"],"StreamChannel":["MyMessage"]},"GuaranteeChannel":{"StreamChannel":["1"]},"_GuaranteeSink":{"StreamSink":["1"]},"StreamChannelMixin":{"StreamChannel":["1"]},"WorkerBeeBase":{"StreamChannel":["1"]}}'));
  B._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"StreamTransformerBase":2,"StreamChannelMixin":1,"_WorkerBeeBase_Object_StreamChannelMixin":2}'));
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      $env_1_1_void: findType("@<~>"),
      Base64Codec: findType("Base64Codec"),
      Event: findType("Event"),
      Future_void: findType("Future<~>"),
      List_int: findType("List<int>"),
      Map_dynamic_dynamic: findType("Map<@,@>"),
      MessageEvent: findType("MessageEvent"),
      MyMessage: findType("MyMessage"),
      Null: findType("Null"),
      Object: findType("Object"),
      StackTrace: findType("StackTrace"),
      StreamChannelController_MyMessage: findType("StreamChannelController<MyMessage>"),
      StreamChannel_MyMessage: findType("StreamChannel<MyMessage>"),
      StreamSink_MyMessage: findType("StreamSink<MyMessage>"),
      Stream_MyMessage: findType("Stream<MyMessage>"),
      String: findType("String"),
      Uint8List: findType("Uint8List"),
      _AsyncCompleter_dynamic: findType("_AsyncCompleter<@>"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _Future_dynamic: findType("_Future<@>"),
      _Future_int: findType("_Future<int>"),
      _Future_void: findType("_Future<~>"),
      _StreamControllerAddStreamState_nullable_Object: findType("_StreamControllerAddStreamState<Object?>"),
      dynamic: findType("@"),
      dynamic_Function_Object: findType("@(Object)"),
      nullable_StackTrace: findType("StackTrace?"),
      nullable__DelayedEvent_dynamic: findType("_DelayedEvent<@>?"),
      nullable_void_Function: findType("~()?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_Object: findType("~(Object)"),
      void_Function_Object_StackTrace: findType("~(Object,StackTrace)")
    };
  })();
  (function constants() {
    D.C_Base64Encoder = new A.Base64Encoder();
    D.C__DelayedDone = new A._DelayedDone();
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal;
    _lazyFinal($, "nullFuture", "$get$nullFuture", () => C.C__RootZone.run$1$1(new A.nullFuture_closure(), B.findType("Future<Null>")));
    _lazyFinal($, "Future__nullFuture", "$get$Future__nullFuture", () => B.findType("_Future<Null>")._as($.$get$nullFuture()));
  })();
};

$__dart_deferred_initializers__["/eAelK8qEon4p+hfo56vyLn3Vl4="] = $__dart_deferred_initializers__.current

//# sourceMappingURL=worker.dart.js_1.part.js.map
